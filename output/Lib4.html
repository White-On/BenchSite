<!DOCTYPE html>

<html lang="en-US">

<head>
    <title>BenchSite</title>
    <meta charset="UTF-8">
    <meta name="description" content="This is the description of the page">
    <meta name="keywords" content="HTML,CSS,JavaScript,Benchmark,Json,Python">
    <meta name="author" content="Jules CASSAN">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Link to the CSS file -->
    <link rel="stylesheet" href="../style/libraryStyle.css">
    <!-- D3.js import  -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
</head>

<body>
    <header id="header-grid">
        <p id="name-logo"><a href="index.html"><b>BenchSite</b></a></p>
        <nav class="header-nav">
            <ul>
                <li><a href="index.html"><b>Home</b></a></li>
                <li><a href="#"><b>About</b></a></li>
                <li><a href="../data.json" download="data.json"><b>Download</b></a></li>
                <li><a href="#"><b>Contact</b></a></li>
            </ul>
        </nav>
        <nav class="header-nav">
            <ul>
                <li><img src="../assets/github.svg" alt="github-icon"></li>
                <li><img src="../assets/envelope-solid.svg" alt="mail-icon"></li>
                <li><img src="../assets/twitter.svg" alt="twitter-icon"></li>
            </ul>
        </nav>
    </header><script src="../script/histogram.js"></script>
<script src="../script/dynamicPlot.js"></script>
<script defer type='module' src='../script/libraryScript.js'></script>

<h1>Lib4</h1>


<a href="Task0.html"><h2 id="entry-title">Task0</h2></a>
<div id="Task0"></div>


<a href="Task1.html"><h2 id="entry-title">Task1</h2></a>
<div id="Task1"></div>


<a href="Task2.html"><h2 id="entry-title">Task2</h2></a>
<div id="Task2"></div>


<a href="Task3.html"><h2 id="entry-title">Task3</h2></a>
<div id="Task3"></div>


<a href="Task4.html"><h2 id="entry-title">Task4</h2></a>
<div id="Task4"></div>


<a href="Task5.html"><h2 id="entry-title">Task5</h2></a>
<div id="Task5"></div>


<a href="Task6.html"><h2 id="entry-title">Task6</h2></a>
<div id="Task6"></div>


<a href="Task7.html"><h2 id="entry-title">Task7</h2></a>
<div id="Task7"></div>


<a href="Task8.html"><h2 id="entry-title">Task8</h2></a>
<div id="Task8"></div>


<a href="Task9.html"><h2 id="entry-title">Task9</h2></a>
<div id="Task9"></div>



<script src="https://d3js.org/d3.v7.min.js"></script>

<script defer>
    var requestURL = "https://raw.githubusercontent.com/White-On/BenchSite-Experiment/main/results.json";

var request = new XMLHttpRequest();
request.open('GET', requestURL);
request.responseType = 'json';
request.send();

let width = window.innerWidth ;
let height = window.innerHeight;

request.onload = function() {
    let data = request.response;
    let AllLibraryName = Object.keys(data);
    let AllTaskName = Object.keys(data[AllLibraryName[0]]);
    let ColorList = ["red", "blue", "green", "yellow", "orange", "purple", "pink", "brown", "grey", "black"]
    let colorPalette = {};
    for (let i = 0; i < AllLibraryName.length; i++) {
        colorPalette[AllLibraryName[i]] = ColorList[i];
    }

    let orderingFunction = (a, b) => d3.ascending(a.runTime, b.runTime);
    for (i = 0; i < AllTaskName.length; i++) {
        let intermediateData = FormatedData({"Lib4" : data["Lib4"]}, AllTaskName[i]);
        // console.log("intermediateData.length = " + intermediateData.length);
        if (intermediateData.length == 1) {
            let intermediateDataSorted = intermediateData.sort(orderingFunction);
            chart = Histogram(intermediateDataSorted, {
                x: d => d.libraryName,
                y: d => d.runTime,
                color: d => colorPalette[d],
                width: width,
                height: height,
                yLabel: "Run Time (ms)",
                labelFontSize: 30,

                marginLeft: 80,
                marginTop: 40,

                Legend: true,

            });
        }
        else{
            chart =  LineChart(intermediateData, {
                x: d => d.arguments,
                y: d => d.runTime,
                z: d => d.libraryName,
                yLabel: "Run Time (ms)",
                width: width,
                height: height,
                color: d => colorPalette[d],
                labelFontSize: 30,
                legendFontSize: 30,
                tooltipFontSize: 30,
                
                marginLeft: 80,
                marginTop: 40,

                legend: true,
                legendColorBoxGap: 10,
                legendColorBoxSize: [40,40],
            });
        }

        let element = document.getElementById(AllTaskName[i]);
        element.appendChild(chart);
    }
}

    function FormatedData(data, TaskName) {
    let LibraryName = Object.keys(data);
    let task 
    
    let formattedData = [];
    for (let j = 0; j < LibraryName.length; j++) {
        task = data[LibraryName[j]][TaskName]['results'];
        let arguments = Object.keys(task).map(x=>+x);
        let results = Object.values(task);
        for (let i = 0; i < arguments.length; i++) {
            formattedData.push({
                arguments: arguments[i],
                runTime: results[i],
                libraryName : LibraryName[j],
            });
        }
    }
    return formattedData;
}


function LineChart(data, {
    x = ([x]) => x, // given d in data, returns the (temporal) x-value
    y = ([, y]) => y, // given d in data, returns the (quantitative) y-value
    z = () => 1, // given d in data, returns the (categorical) z-value
    title, // given d in data, returns the title text
    defined, // for gaps in data

    curve = d3.curveBumpX, // method of interpolation between points

    marginTop = 20, // top margin, in pixels
    marginRight = 30, // right margin, in pixels
    marginBottom = 30, // bottom margin, in pixels
    marginLeft = 50, // left margin, in pixels

    width = 640, // outer width, in pixels
    height = 400, // outer height, in pixels

    xType = d3.scaleLinear, // type of x-scale
    yType = d3.scaleLinear, // type of y-scale

    xDomain, // [xmin, xmax]
    yDomain, // [ymin, ymax]

    xRange = [marginLeft, width - marginRight], // [left, right]
    yRange = [height - marginBottom, marginTop], // [bottom, top]

    yFormat, // a format specifier string for the y-axis
    yLabel, // a label for the y-axis
    zDomain, // array of z-values
    labelFontSize = 20, // font size of axis labels

    color = "currentColor", // stroke color of line, as a constant or a function of *z*

    strokeLinecap, // stroke line cap of line
    strokeLinejoin, // stroke line join of line
    strokeWidth = 2, // stroke width of line
    strokeOpacity = 1, // stroke opacity of line

    circlesRadius = 5, // radius of circles

    tooltipFontSize = 15, // font size of tooltip text
    tooltipBoxSize = [100, tooltipFontSize*2],
    tooltipCircleRadius = circlesRadius*2,
    tooltipTopMargin = tooltipCircleRadius + 10,

    mixBlendMode = "multiply", // blend mode of lines

    legend = false, // show a legend?
    xLegend = width*0.1, // x-axis legend
    yLegend = height*0.1, // y-axis legend
    legendColorBoxSize = [20, 20], // size of the color box in the legend
    legendColorBoxGap = 5, // margin of the color box in the legend
    legendFontSize = 20, // font size of the legend

    graphicalreduction = 0.05, // graphical reduction of the chart 

    voronoi // show a Voronoi overlay? (for debugging)
    } = {}) {
    // Compute values.
    // We compute the x, y, z, and defined values for each data point.
    const X = d3.map(data, x);
    const Y = d3.map(data, y);
    const Z = d3.map(data, z);
    const O = d3.map(data, d => d);
    if (defined === undefined) defined = (d, i) => !isNaN(X[i]) && !isNaN(Y[i]);
    const D = d3.map(data, defined);

    // Compute default domains, and unique the z-domain.
    // The Domain is the range of values that the data can take on.
    const xMinMaxValue = d3.extent(X);
    const xDynamicRange = xMinMaxValue[1] - xMinMaxValue[0];
    
    const yMinMaxValue = [d3.min(Y, d => typeof d === "string" ? +d : d), d3.max(Y, d => typeof d === "string" ? +d : d)];
    const yDynamicRange = yMinMaxValue[1] - yMinMaxValue[0];

    if (xDomain === undefined) xDomain = [xMinMaxValue[0] - xDynamicRange*graphicalreduction, xMinMaxValue[1] + xDynamicRange*graphicalreduction];
    // if Y is a string, then we need to coerce it to a number.
    if (yDomain === undefined) yDomain = [yMinMaxValue[0] - yDynamicRange*graphicalreduction, yMinMaxValue[1] + yDynamicRange*graphicalreduction];
    // zDomain is the set of all possible values that the z variable can take on.
    if (zDomain === undefined) zDomain = Z;
    zDomain = new d3.InternSet(zDomain);

    // Omit any data not present in the z-domain.
    const I = d3.range(X.length).filter(i => zDomain.has(Z[i]));

    // Construct scales and axes.
    const xScale = xType(xDomain, xRange);
    const yScale = yType(yDomain, yRange);
    const xAxis = d3.axisBottom(xScale).ticks(width / 80).tickSizeOuter(0);
    const yAxis = d3.axisLeft(yScale).ticks(height / 60, yFormat);

    // Compute titles.
    const T = title === undefined ? Z : title === null ? null : d3.map(data, title);

    // Construct a line generator.
    // Take the data point by point, and draw a line between them acording to the curve specified.
    const line = d3.line()
        .defined(i => D[i])
        .curve(curve)
        .x(i => xScale(X[i]))
        .y(i => yScale(Y[i]));

    // Construct a new SVG. this is the main container for the chart.
    const svg = d3.create("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [0, 0, width, height])
        .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
        .style("-webkit-tap-highlight-color", "transparent")
        // all of the following are for accessibility ans interaction.
        .on("pointerenter", pointerentered)
        .on("pointermove", pointermoved)
        .on("pointerleave", pointerleft)
        .on("touchstart", event => event.preventDefault());

    // optional Voronoi display (for fun).
    // this is a way to see the points that are being used to draw the line.
    if (voronoi) svg.append("path")
        .attr("fill", "none")
        .attr("stroke", "#ccc")
        .attr("d", d3.Delaunay
            .from(I, i => xScale(X[i]), i => yScale(Y[i]))
            .voronoi([0, 0, width, height])
            .render());
    
    // add the x-axis to the chart.
    svg.append("g")
        .attr("transform", `translate(0,${height - marginBottom})`)
        .call(xAxis)
        .attr("font-size", labelFontSize)
        .call(g => g.select(".domain").remove())
        .call(voronoi ? () => {} : g => g.selectAll(".tick line").clone()
            .attr("y2", marginTop + marginBottom - height)
            .attr("stroke-opacity", 0.1));

    // add the y-axis to the chart.
    svg.append("g")
        .attr("transform", `translate(${marginLeft},0)`)
        .call(yAxis)
        .attr("font-size", labelFontSize)
        .call(g => g.select(".domain").remove())
        .call(voronoi ? () => {} : g => g.selectAll(".tick line").clone()
            .attr("x2", width - marginLeft - marginRight)
            .attr("stroke-opacity", 0.1))
        .call(g => g.append("text")
            .attr("x", -marginLeft)
            .attr("y", 10 + labelFontSize/2)
            .attr("fill", "currentColor")
            .attr("text-anchor", "start")
            .text(yLabel));
    
    // add circles to the chart where the datapoints are
    const circles = svg.append("g");

    circles
        .attr("fill", typeof color === "string" ? color : null)
        .selectAll("circle")
        .data(I)
        .join("circle")
        .attr("cx", (I) => xScale(X[I]))
        .attr("cy", (I) => yScale(Y[I]))
        .attr("r", circlesRadius)
        .attr("fill", typeof color === "function" ? (i) => color(Z[i]) : null);

    // add the line to the chart.
    const path = svg.append("g")
        .attr("fill", "none")
        .attr("stroke", typeof color === "string" ? color : null)
        .attr("stroke-linecap", strokeLinecap)
        .attr("stroke-linejoin", strokeLinejoin)
        .attr("stroke-width", strokeWidth)
        .attr("stroke-opacity", strokeOpacity)
        .selectAll("path")
        .data(d3.group(I, i => Z[i]))
        .join("path")
        .style("mix-blend-mode", mixBlendMode)
        .attr("stroke", typeof color === "function" ? ([z]) => color(z) : null)
        .attr("d", ([, I]) => line(I));
    
    

    // add the dot when the mouse is over the line.
    const dot = svg.append("g")
        .attr("display", "none");

    dot.append("circle")
        .attr("r", tooltipCircleRadius);

    dot.append("path")
        .attr("fill", "white")
        .attr("stroke", "black")
        .attr("stroke-width", 2)
        .attr("d", `M${-tooltipBoxSize[0] / 2  },5H-5l5,-5l5,5H${tooltipBoxSize[0] / 2 }v${tooltipBoxSize[1]}h-${tooltipBoxSize[0]}z`)
        .attr("transform", `translate(0,${tooltipTopMargin})`);
    
    dot.append("text")
        .attr("font-family", "sans-serif")
        .attr("font-size", tooltipFontSize)
        .attr("fill", "black")
        .attr("text-anchor", "middle")
        .attr("y", tooltipBoxSize[1]/2 + tooltipFontSize/2 + tooltipTopMargin + 5);


    function swatches() {
        // adding the swatches to the chart.
        const swatches = svg.append("g")
            .attr("font-family", "sans-serif")
            .attr("font-size", legendFontSize)
            .attr("text-anchor", "start")
            .selectAll("g")
            .data(zDomain)
            .join("g")
            .attr("transform", (z, i) => `translate(0,${i * legendColorBoxSize[1] + i * legendColorBoxGap })`);
        
        // adding the swatch color to the chart.

        swatches.append("rect")
            .attr("x", xLegend)
            .attr("y", yLegend )
            .attr("width", legendColorBoxSize[0])
            .attr("height", legendColorBoxSize[1])
            .attr("fill", color);

        // adding the swatch text to the chart.
        swatches.append("text")
            .attr("x", xLegend + legendColorBoxSize[0] + legendColorBoxGap)
            .attr("y", yLegend + legendColorBoxSize[1]/2 - legendFontSize/2)
            .attr("dy", "1em")
            // .text(z => z)
            .html(function(z){ return "<a href=\"" + z + ".html\">"+ z +"</a>"; });

        return swatches;
    }

    // add the swatches to the chart.
    if (legend) swatches();

    function pointermoved(event) {
        const [xm, ym] = d3.pointer(event);
        const i = d3.least(I, i => Math.hypot(xScale(X[i]) - xm, yScale(Y[i]) - ym)); // closest point
        // console.log(Z[i]);
        
        path.style("stroke", ([z]) => Z[i] === z ? null : "#ddd").filter(([z]) => Z[i] === z).raise();
        path.style("stroke-width", ([z]) => Z[i] === z ? circlesRadius*2 : null).filter(([z]) => Z[i] === z).raise();
        dot.attr("transform", `translate(${xScale(X[i])},${yScale(Y[i])})`);
        dot.style("fill", color(Z[i]));
        circles.selectAll('circle').style("fill", "#ddd");
        // TODO fix the Titles
        if (T) dot.select("text").text(Y[i].toFixed(2));
        svg.property("value", O[i]).dispatch("input", {bubbles: true});
    }

    function pointerentered() {
        path.style("mix-blend-mode", null).style("stroke", "#ddd");
        dot.attr("display", null);
    }

    function pointerleft() {
        circles.selectAll('circle').style("fill", null);
        path.style("mix-blend-mode", mixBlendMode).style("stroke", null).style("stroke-width", null);
        dot.attr("display", "none");
        svg.node().value = null;
        svg.dispatch("input", {bubbles: true});
    }

    return Object.assign(svg.node(), {value: null});
}

function Histogram(data, {
    x = ([x]) => x, // given d in data, returns the (temporal) x-value
    y = ([, y]) => y, // given d in data, returns the (quantitative) y-value

    width = 640,
    height = 400,

    marginTop = 20, // top margin, in pixels
    marginRight = 30, // right margin, in pixels
    marginBottom = 30, // bottom margin, in pixels
    marginLeft = 50, // left margin, in pixels

    xDomain = undefined, // [x0, x1], or undefined to auto-detect
    yDomain = undefined, // [y0, y1], or undefined to auto-detect
    xRange = [marginLeft , width - marginRight], // [x0, x1]
    yRange = [height - marginBottom, marginTop], // [y0, y1]

    yType = d3.scaleLinear, // y-axis scale type
    yFormat = d3.format(".2s"), // y-axis tick format

    yLabel = "", // y-axis label
    labelFontSize = 20, // font size of the label

    xPadding = 0.2, // padding between bars on the x-axis

    color = "steelblue", // bar color

    legend = true, // show legend
    xLegend = width*0.1, // x-axis legend
    yLegend = height*0.1, // y-axis legend
    legendColorBoxSize = [20, 20], // size of the color box in the legend
    legendColorBoxGap = 5, // margin of the color box in the legend
    legendFontSize = 20, // font size of the legend

    } = {}) {
    const X = d3.map(data, x); // x-values
    const Y = d3.map(data, y); // y-values
    
    if (xDomain === undefined) xDomain = X;
    if (yDomain === undefined) yDomain = [0, d3.max(Y)];
    xDomain = new d3.InternSet(xDomain);

    // Omit any data not present in the x-domain.
    const I = d3.range(X.length).filter(i => xDomain.has(X[i]));

    // The scale for the x-axis. Note that the x-axis is a band scale.
    const xScale = d3.scaleBand(xDomain, xRange).padding(xPadding);
    // The scale for the y-axis.
    const yScale = yType(yDomain, yRange);

    const xAxis = d3.axisBottom(xScale).tickSizeOuter(0);
    const yAxis = d3.axisLeft(yScale).ticks(height / 40, yFormat);

    const format = yScale.tickFormat(100, yFormat);
    
    // the main svg element
    const svg = d3.create("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [0, 0, width, height])
        .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
        .style("-webkit-tap-highlight-color", "transparent")
    
    // X-axis 
    const xGroup = svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(xAxis)
      .style("font-size", labelFontSize);
    
    // Y-axis 
    const yGroup = svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(yAxis)
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick").call(grid))
      .call(g => g.append("text")
            .attr("x", -marginLeft)
            .attr("y", 10 + labelFontSize / 2)
            .attr("fill", "currentColor")
            .attr("text-anchor", "start")
            .text(yLabel))
            .style("font-size", labelFontSize);
    
    // create the bars
    let rect = svg.append("g")
      .attr("fill", typeof color === "string" ? color : null)
        .selectAll("rect")
        .data(I)
        .join("rect")
        .call(position, i => xScale(X[i]), i => yScale(Y[i]))
        .style("mix-blend-mode", "multiply")
        .attr("fill", typeof color === "function" ? (i) => color(X[i]) : null)
        .call(rect => rect.append("title")
            .text(i => [X[i], `${format(Y[i])} sec`].join("\n")));
    
    // create the legend
    function grid(tick) {
        return tick.append("line")
            .attr("class", "grid")
            .attr("x2", width - marginLeft - marginRight)
            .attr("stroke", "currentColor")
            .attr("stroke-opacity", 0.1);
    }

    // position the bars
    function position(rect, x, y) {
        rect
            .attr("x", x)
            .attr("y", y)
            .attr("width", xScale.bandwidth())
            .attr("height", i => yScale(0) - yScale(Y[i]));
    }


    // adding the swatches to the chart.
    function swatches() {
        const swatches = svg.append("g")
            .attr("font-family", "sans-serif")
            .attr("font-size", legendFontSize)
            .attr("text-anchor", "start")
            .selectAll("g")
            .data(xDomain)
            .join("g")
            .attr("transform", (z, i) => `translate(0,${i * legendColorBoxSize[1] + i * legendColorBoxGap })`);
        
        // adding the swatch color to the chart.

        swatches.append("rect")
            .attr("x", xLegend)
            .attr("y", yLegend )
            .attr("width", legendColorBoxSize[0])
            .attr("height", legendColorBoxSize[1])
            .attr("fill", color);

        // adding the swatch text to the chart.
        swatches.append("text")
            .attr("x", xLegend + legendColorBoxSize[0] + legendColorBoxGap)
            .attr("y", yLegend + legendColorBoxSize[1]/2 - legendFontSize/2)
            .attr("dy", "1em")
            // text attribute is used to set the text content of the element.
            // .text(z => z)
            // html attribute is used to set the innerHTML of the element. here a function is used to create the link.
            .html(function(z){ return "<a href=\"" + z + ".html\">"+ z +"</a>"; });
        
        return swatches;
    }

    if (legend) swatches();

    return Object.assign(svg.node(), {value: null});
}
</script>
</body>